"""
Create sets of terms (facets, search terms) to use in benchmark tests.
"""
from solrfixtures.mathtools import clamp
from solrfixtures.emitter import Emitter, RandomEmitter
from solrfixtures.emitters.choice import Choice, chance
from solrfixtures.emitters.fixed import Static
from solrfixtures.emitters.text import Text
from solrfixtures.group import ObjectMap


def make_search_terms(vocab_words, vocab_chooser, phrase_length_factors=None):
    """
    Generate unique search terms/phrases to use in benchmarking.

    Provide the 'vocab_words' -- a sequence of unique vocabulary words,
    and a 'vocab_chooser' -- a solrfixtures Emitter-like instance that
    chooses and emits the vocabulary terms (such as a Choice emitter).

    By default, per 100 'vocab_terms' this generates:
        - 100 1-word terms. (I.e., all provided vocab_terms are used.)
        - 50 2-word terms.
        - 30 3-word terms.
        - 16 4-word terms.
        - 4 5-word terms.

    You can change how many of each length are generated by passing a
    custom `phrase_length_factors` list. [1.0, 0.5, 0.3, 0.16, 0.04]
    is the default. If you want phrases with more or fewer words, just
    provide the appropriate number of elements.

    Returns a dict, such as: {
        '1-word': [100 1-word terms],
        '2-word': [50 2-word terms],
        '3-word': [30 3-word terms],
        '4-word': [16 4-word terms],
        '5-word': [4 5-word terms],
        'all': [All 200 terms]
    }

    Term lists are sorted shortest to longest before they are returned.
    """
    plfactors = phrase_length_factors or [1.0, 0.5, 0.3, 0.16, 0.04]
    terms = {'1-word': [], 'all': []}
    vocab_length = len(vocab_words)
    for i, plfactor in enumerate(plfactors):
        term_length = i + 1
        num_desired = int(round(vocab_length * plfactor))
        if term_length == 1:
            new_terms = list(vocab_words)
        else:
            phrase_emitter = Text(Static(term_length), vocab_chooser)
            new_terms = phrase_emitter(num_desired)
        new_terms = sorted(new_terms, key=lambda v: (len(v), v))
        terms[f'{term_length}-word'] = new_terms
        terms['all'].extend(new_terms)
    return terms


def make_facet_terms(total_docs, facet_params, cardinality_floor=10):
    """
    Generate sets of facet terms based on a set of `facet_params`.

    The given `facet_params` should be a `parameters.FacetFieldParams`
    object. A set of unique terms is generated for each facet, where
    how many terms (cardinality) is controlled by `facet_params` and
    the total number of documents being generated (`total_docs`).

    You can set a default `cardinality_floor` to be used as the
    smallest number of terms that can be generated (if not overridden
    in `facet_params`). Default is 10.

    Returns a dict, where keys reflect facet fields (and are identical
    to keys in `facet_params`) and values are term lists for each
    corresponding facet field.
    """
    terms = {}
    for field, p in facet_params.items():
        fterms = set([])
        card = p.cardinality
        if card is None:
            floor = p.get('card_floor', cardinality_floor)
            multiplier = p.occ_factor * p.card_factor
            card = clamp(round(total_docs * multiplier), mn=floor)
        terms[field] = p.emitter(card)
    return terms


class TermChoice(Emitter):
    """Ensures all terms are chosen when choosing from a term set."""

    def __init__(self, choice_emitter):
        self._emitters = ObjectMap({})
        self.choice_emitter = choice_emitter
        self.unique_emitter = Choice(
            choice_emitter.items,
            weights=choice_emitter.weights,
            unique=True,
            each_unique=False,
            noun=choice_emitter.noun,
            rng_seed=choice_emitter.rng_seed
        )
        self.reset()

    @property
    def choice_emitter(self):
        return self._emitters['choice']

    @choice_emitter.setter
    def choice_emitter(self, choice_emitter):
        self._emitters['choice'] = choice_emitter

    @property
    def unique_emitter(self):
        return self._emitters['unique']

    @unique_emitter.setter
    def unique_emitter(self, unique_emitter):
        self._emitters['unique'] = unique_emitter

    def reset(self):
        self._emitters.do_method('reset')
        self.active_emitter = self.unique_emitter

    def seed(self, rng_seed):
        self._emitters.do_method('seed', rng_seed)

    def emit(self):
        try:
            return self.active_emitter()
        except ValueError:
            self.active_emitter = self.choice_emitter
            return self.active_emitter()

    def emit_many(self, number):
        try:
            return self.active_emitter(number)
        except ValueError:
            unique_remaining = self.active_emitter.num_unique_values
            result = self.active_emitter(unique_remaining)
            self.active_emitter = self.choice_emitter
            result.extend(self.active_emitter(number - unique_remaining))
            return result


class TermInjector(RandomEmitter):
    """Allows injecting terms into the output of another emitter."""

    def __init__(self, source_emitter, term_emitter, inject_chance=10,
                 rng_seed=None):
        self._emitters = ObjectMap({})
        self.source_emitter = source_emitter
        self.term_emitter = term_emitter
        self.chance = inject_chance
        self.rng_seed = rng_seed
        self.reset()

    @property
    def source_emitter(self):
        return self._emitters['source']

    @source_emitter.setter
    def source_emitter(self, source_emitter):
        self._emitters['source'] = source_emitter

    @property
    def term_emitter(self):
        return self._emitters['term']

    @term_emitter.setter
    def term_emitter(self, term_emitter):
        self._emitters['term'] = term_emitter

    def reset(self):
        super().reset()
        self._emitters.setattr('rng_seed', self.rng_seed)
        self._emitters.do_method('reset')

    def seed(self, rng_seed):
        super().seed(rng_seed)
        self._emitters.do_method('seed', rng_seed)

    def _inject(self, new_term, old_term):
        pos = self.rng.choice(range(1, len(old_term)))
        return ' '.join([old_term[:pos], new_term, old_term[pos:]]).strip()

    def emit(self):
        if self.rng.choices([True, False], cum_weights=[self.chance, 100])[0]:
            if self.rng.choice([True, False]):
                return self.term_emitter()
            return self._inject(self.term_emitter(), self.source_emitter())
        return self.source_emitter()

    def emit_many(self, number):
        inject_choices = self.rng.choices([True, False], k=number,
                                          cum_weights=[self.chance, 100])
        overwrite_choices = self.rng.choices([True, False], k=number)
        new_terms = self.term_emitter(number)
        old_terms = self.source_emitter(number)
        zipped = zip(inject_choices, overwrite_choices, new_terms, old_terms)
        results = []
        for inject, overwrite, new, old in zipped:
            if inject:
                if overwrite:
                    results.append(self._inject(new, old))
                else:
                    results.append(new)
            else:
                results.append(old)
        return results
